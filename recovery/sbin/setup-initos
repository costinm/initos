#!/bin/sh

# Build script for initos. The functions are called typically called in a docker container - but should work
# on any VM that has the right tools.
#
# The results:
# - creating a 'base-recovery' image, that can be run in Docker in a trusted machine to generate signed
# artifacts including bootstrap ssh authorized keys and user-specific roots of trust.
#
# - creation of a directory containing all artifacts needed for install by copying to an existing
# USB EFI partition.
#

set -x
set -e

# Work dir for temp files/cache.
# Can be a btrfs subvolume, or a tmpfs. I have a btrfs mounted on/x/, and use vol
# for 'volumes'.
WORK=${WORK:-/x/initos}

# For running the steps that need a container, use this shared dir and source dir.
# Should be mounted in docker, will be created on the USB/recovery.
SRCDIR=${SRCDIR:-/ws/initos}

# If the source dir is mounted, use it as a prefix to load fresh files
# Otherwise - use the files in the recovery image.
#if [ -d $SRCDIR/recovery ]; then
#  cp -a $SRCDIR/recovery/sbin/* /sbin/
#  cp -a $SRCDIR/recovery/etc/* /etc
#fi

## All functions after this line are run inside a container, chroot or host running
# 'recovery' or alpine installer or distro.

# Downloads the linux (alpine).
#
# Very slow, installs a lot of firmware.
# The kernel will be packed into the UKI by a separate step.
#
# Expects /lib/firmware, /lib/modules and /boot to be mounted to either a work dir
# or /x/initos subvolumes
#
# The /boot dir on the container or real hosts will not have any of the files - they
# are used to build the UKI in the EFI partition and modules/firmware go to different
# subvolumes.
linux_alpine() {
  apk add linux-lts
  apk add intel-ucode amd-ucode

  KERNEL_VERSION=$(cat /usr/share/kernel/lts/kernel.release)

  # This is the version that will be used in the UKI (can be changed)
  echo $KERNEL_VERSION > /boot/version

  # Versioned name, matching the modules dir.
  mv /boot/vmlinuz-lts /boot/vmlinuz-${KERNEL_VERSION}
  ln -s /boot/vmlinuz-${VKERNEL_VERSION}  /boot/vmlinuz
}

# vlinux_alpine gets the virtual kernel, creates a squash with the modules.
vlinux_alpine() {
  # Also get virt since we are here...
  apk add linux-virt

  VKERNEL_VERSION=$(cat /usr/share/kernel/virt/kernel.release)
  echo $VKERNEL_VERSION > /boot/version-virt

  mv /boot/vmlinuz-virt /boot/vmlinuz-${VKERNEL_VERSION}
  ln -s /boot/vmlinuz-${VKERNEL_VERSION}  /boot/vmlinuz-virt

  mkdir -p ${WORK}/virt
  vinit $VKERNEL_VERSION
  if [ ! -f $WORK/virt/modloop-${VKERNEL_VERSION}.sqfs ]; then
    mksquashfs /lib/modules/${VKERNEL_VERSION} $WORK/virt/modloop-${VKERNEL_VERSION}.sqfs
  fi
}

# vinit updates the initramfs for the virt kernel, in case init script is changed.
vinit() {
  VKERNEL_VERSION=$(cat /boot/version-virt)
  # -k - keep the file
  # -t - temp dir where all is stored

  rm -rf ${WORK}/virt/initfs
  mkdir -p ${WORK}/virt/initfs
  mkinitfs -k -t ${WORK}/virt/initfs  -i /sbin/init-vm -F "base btrfs squashfs virtio initos" -o ${WORK}/virt/initramfs-$VKERNEL_VERSION $VKERNEL_VERSION
}

# Generate an unsigned efi image, based on alpine with a custom init script.
# alpine_initrd is run in an alpine container, rescue or chroot.
#
# The init image will be generated in /boot/initramfs.
# Modules are expected to be in /lib/modules/modules-KERNEL_VERSION
# Kernel is expected to be in /boot/vmlinux-KERNEL_VERSION
#
# For secure mode, kernel+initrd+cmdline are signed, but the rootfs needs to
# be either signed or on a LUKS partition ( where encryption+signing happens as well).
#
# In the first case, normally the SHA of the rootfs needs to be passed as an argument
# either in kernel cmdline or as a file in initrd.
#
# The '@firmware' and '@modules' subvolumes must also be created
# if using separate volumes - for now they're in @recovery rootfs.
efi() {

  # Expects that the modloop is already created, and the cache under ${WORK}/modules may
  # exist.
  EFI_FILE=${EFI_FILE:-/boot/efi/EFI/BOOT/Initos-NEW.EFI}

  KERNEL_VERSION=$(cat /boot/version)
  [ -z ${KERNEL_VERSION} ] && echo "Missing kernel config" && return

  KERNEL=/boot/vmlinuz-${KERNEL_VERSION}
  [ ! -f ${KERNEL} ] && echo "Missing kernel ${KERNEL}" && return

  [ ! -f /lib/modules/${KERNEL_VERSION}/modules.dep ] && echo "Missing modules" && return

  local img=/boot/initrd-initos.img-${KERNEL_VERSION}

  build_initrd ${KERNEL_VERSION} ${img}

  echo "loglevel=6 console=ttyS0 console=tty1 net.ifnames=0 panic=5 debug_init iomem=relaxed" > /boot/cmdline

  mkdir -p /boot/efi/EFI/BOOT
  efi-mkuki \
    -c /boot/cmdline \
    -o ${EFI_FILE} \
      ${KERNEL} /boot/intel-ucode.img /boot/amd-ucode.img ${img}

  echo ${KERNEL_VERSION} > /boot/efi/version
}

build_initrd() {
  local KERNEL_VERSION=$1
  local img=$2

  echo "Built initramfs ${img} for ${KERNEL_VERSION}"

  local KERNEL=/boot/vmlinuz-${KERNEL_VERSION}
  [ ! -f ${KERNEL} ] && echo "Missing kernel ${KERNEL}" && return

  [ ! -f /lib/modules/${KERNEL_VERSION}/modules.dep ] && echo "Missing modules" && return

    # Uses mkinitfs.conf added from file in the docker image.
    # Other options: virtio, squashfs, 9p, raid, cdrom, lvm, ext4, kms (video)

    # -k - keep the file
    # -t - temp dir where all is stored
    # -i - what init file to use - replace default with our script.
    #rm -rf ${WORK}/initrd
    # -k -t ${WORK}/initrd
    local img=/boot/initrd-initos.img-${KERNEL_VERSION}

    echo "features=\"ata base btrfs keymap mmc nvme scsi usb cryptsetup squashfs tpm2 clevis initos eudev\"" > /etc/mkinitfs/mkinitfs.conf
    cp /etc/passwd /usr/share/mkinitfs/passwd
    cp /etc/group /usr/share/mkinitfs/group
    #cp /boot/efi/hash* /boot/

    rm -rf ${WORK}/initfs.host
    mkinitfs -k -t ${WORK}/initfs.host -i /sbin/init-usb -o ${img}  $KERNEL_VERSION
}

# sign creates a signed UKI.
# The initramfs is different - the additional file will disable shell and trigger verification.
sign() {
  set -e
  local KERNEL_VERSION=$(cat /boot/version)

  # Need to rebuild the initrd - for some reason the hash is not found.

  # Alpine expects keys on /etc/uefi-keys/{db.crt,db.key}
  if [ ! -f /etc/uefi-keys/db.crt ]; then
    sign_init
  fi
  if [ ! -f /etc/uefi-keys/root.pem ]; then
      openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 -out /etc/uefi-keys/root.key
      openssl ec -in /etc/uefi-keys/root.key -pubout -out /etc/uefi-keys/root.pem
      ssh-keygen -y -f /etc/uefi-keys/root.key > /etc/uefi-keys/authorized_keys
    fi
    cp /etc/uefi-keys/root.pem /boot/efi/EFI
    cp /etc/uefi-keys/root.pem /boot/

  KERNEL=/boot/vmlinuz-${KERNEL_VERSION}

  # The hash must be on the signed initrd - not on the efi disk (which is mounted)
  cp /boot/efi/hash* /boot/
  (find /boot/hash* /boot/root.pem | sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > /boot/initos-hashes.cpio.gz

  # TODO: add authorized_keys and root.pem

  echo "loglevel=0 quiet console=ttyS0 console=tty1 net.ifnames=0 panic=5 rdinit=/sbin/init-secure initos.secure" > /boot/cmdline.secure

  efi-mkuki \
    -c /boot/cmdline.secure \
    -o /boot/efi/EFI/BOOT/tmp-${KERNEL_VERSION}.EFI \
      ${KERNEL} \
       /boot/intel-ucode.img /boot/amd-ucode.img \
       /boot/initrd-initos.img-${KERNEL_VERSION} /boot/initos-hashes.cpio.gz

   #    ${WORK}/initos-secure.cpio.gz

  sbsign --cert /etc/uefi-keys/db.crt --key /etc/uefi-keys/db.key \
    --output /boot/efi/EFI/BOOT/BOOTX64.EFI \
    /boot/efi/EFI/BOOT/tmp-${KERNEL_VERSION}.EFI
  echo ${KERNEL_VERSION} > /boot/efi/EFI/BOOT/BOOTX64.version
  echo ${KERNEL_VERSION} > /boot/efi/EFI/BOOT/BOOTX64.${KERNEL_VERSION}
  rm /boot/efi/EFI/BOOT/tmp-${KERNEL_VERSION}.EFI

  cp /etc/uefi-keys/*`.auth` /boot/efi/EFI
  cp /etc/uefi-keys/*`crt` /boot/efi/EFI
  cp /etc/uefi-keys/*`cer` /boot/efi/EFI


  chmod 755 /boot/efi/EFI/*.auth
  chmod 755 /boot/efi/EFI/*.crt
  chmod 755 /boot/efi/EFI/*.cer

  rm /.dockerenv
  # TODO: also sign the squash and modules
}


# Incremental efi build - only replaces init
efi2() {
  KERNEL_VERSION=$(cat /boot/version)
  KERNEL=/boot/vmlinuz-${KERNEL_VERSION}
  local img=/boot/initrd-initos.img-${KERNEL_VERSION}
  cp /sbin/init-usb  /init
 (find /init | sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > /boot/initos-xtra.cpio.gz
 (find /boot/efi/hash* | sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > /boot/initos-hashes.cpio.gz

  echo "loglevel=6 console=ttyS0 console=tty1 net.ifnames=0 panic=5 debug_init iomem=relaxed" > /boot/cmdline

  mkdir -p /boot/efi/EFI/BOOT
  efi-mkuki \
    -c /boot/cmdline \
    -o /boot/efi/EFI/BOOT/Initos-NEW.EFI \
      ${KERNEL} /boot/intel-ucode.img /boot/amd-ucode.img ${img} /boot/initos-hashes.cpio.gz /boot/initos-xtra.cpio.gz

}


sqfs() {
  version=${1:-$(cat /boot/version)}
  firmware_sqfs
  mod_sqfs $version
}

# firmware_sqfs builds /boot/efi/firmware.sqfs using /x/initos/firmware or /lib/firmware
firmware_sqfs() {

  DST=${DST:-/boot/efi}

  if [ -d /x/initos/firmware ]; then
    cd /x/initos/firmware
  elif [ -d /lib/firmware ]; then
    cd /lib/firmware
  else
    echo "No firmware found"
    return
  fi

  rm -f ${DST}/firmware${SUFFIX}.sqfs
  mksquashfs . ${DST}/firmware${SUFFIX}.sqfs
  veritysetup format --root-hash-file=${DST}/hash.firmware${SUFFIX} ${DST}/firmware${SUFFIX}.sqfs ${DST}/firmware${SUFFIX}.sqfs.verity
}

# mod_sqfs builds /boot/efi/modules-${version}.sqfs
# Source should be in /x/initos/modules/${version} or /lib/modules/${version}
mod_sqfs() {
  ver=${1:-$(cat /boot/version)}

  DST=${DST:-/boot/efi}

  if [ -z "$ver" ]; then
    echo "No version specified"
    return
  fi

  if [ -d /x/initos/modules/${ver} ]; then
    cd /x/initos/modules/${ver}
  elif [ -d /lib/modules/${ver} ]; then
    cd /lib/modules/${ver}
  else
    echo "No modules found for ${ver}"
    return
  fi

  rm -f ${DST}/modules-${ver}.sqfs
  mksquashfs . ${DST}/modules-${ver}.sqfs
  veritysetup format --root-hash-file=${DST}/hash.modules-${ver} \
     ${DST}/modules-${ver}.sqfs \
     ${DST}/modules-${ver}.sqfs.verity
}

recovery_sqfs() {
  DST=${DST:-/boot/efi}
  out=${out:-recovery}

  # -one-file-system also works on the host - but not so well in a container.
  cd /
  rm -f ${DST}/recovery.sqfs

  mksquashfs  . ${DST}/${out}.sqfs \
    -regex -e "x/.*" -e "lib/modules/.*" -e "lib/firmware/.*" -e "boot/.*" \
     -e "proc/.*" -e "sys/.*" -e "run/.*" -e "work/.*" -e "ws/.*" -e "etc/apk/cache.*"

  veritysetup format --root-hash-file=${DST}/hash.${out} ${DST}/${out}.sqfs ${DST}/${out}.sqfs.verity
}


# Generate the key pairs for signing the kernel and the disk image.
# This is done before install - as a separate step/process - the rest can be automated easily,
# but signing must be done on a secure machine and is specific to each user.
sign_init() {
  local u=${1:-h.webinf.info}

  mkdir -p /x/secure
  efi-mkkeys -s h.webinf.info
}

chk_firmware() {
  set +x
  # Get a list of all loaded modules - mostly AI generated.
  modules=$(lsmod | awk 'NR>1 {print $1}')

  for module in $modules; do
    modinfo_output=$(/usr/sbin/modinfo $module)

    # Extract firmware information
    #firmware_lines=$(echo "$modinfo_output" | grep -i 'firmware:')
    firmware_lines=$(echo "$modinfo_output" | grep -ioE 'firmware:[[:space:]][^ ]+' | cut -d ' ' -f2-)

    if [ -n "$firmware_lines" ]; then
      echo $module
      while read -r firmware; do
          echo "$module: $firmware"
      done < "$firmware_lines"
    fi
  done
}

alpine_clear() {
  rm /var/lib/dbus/machine-id || true
  rm /etc/hostname || true
  echo "" > /etc/machine-id || true
}


# Add the Alpine ISO image to the boot disk (expanded to EFI instead of ISO)
# This is useful for recovery if recovery fails. 
efi_alpine_installer() {
  set -e
  mkdir -p ${DIST} ${WORK}/boot

    if [ ! -f ${WORK}/alpine.iso ]; then
      curl -Lo ${WORK}/alpine.iso https://dl-cdn.alpinelinux.org/alpine/v3.20/releases/x86_64/alpine-standard-3.20.3-x86_64.iso
    fi
    cd ${WORK}/dist
    bsdtar xf ${WORK}/alpine.iso
    cfgf=$(ls ${DIST}/boot/config-*)

}


$*
