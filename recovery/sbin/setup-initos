#!/bin/sh

# Build script for initos. The functions are called typically called in a docker container - but should work
# on any VM that has the right tools.
#
# The results:
# - creating a 'base-recovery' image, that can be run in Docker in a trusted machine to generate signed
# artifacts including bootstrap ssh authorized keys and user-specific roots of trust.
#
# - creation of a directory containing all artifacts needed for install by copying to an existing
# USB EFI partition.
#

set -x
set -e

# Work dir for temp files/cache.
# Can be a btrfs subvolume, or a tmpfs. I have a btrfs mounted on/x/, and use vol
# for 'volumes'.
WORK=${WORK:-/x/initos}

# For running the steps that need a container, use this shared dir and source dir.
# Should be mounted in docker, will be created on the USB/recovery.
SRCDIR=${SRCDIR:-/ws/initos}

## All functions after this line are run inside a container, chroot or host running
# 'recovery' or alpine installer or distro.

# Downloads the linux (alpine).
#
# Very slow, installs a lot of firmware.
# The kernel will be packed into the UKI by a separate step.
#
# Expects /lib/firmware, /lib/modules and /boot to be mounted to either a work dir
# or /x/initos subvolumes
#
# The /boot dir on the container or real hosts will not have any of the files - they
# are used to build the UKI in the EFI partition and modules/firmware go to different
# subvolumes.
linux_alpine() {
  apk add intel-ucode amd-ucode
  apk add linux-lts

  KERNEL_VERSION=$(cat /usr/share/kernel/lts/kernel.release)

  # This is the version that will be used in the UKI (can be changed)
  echo $KERNEL_VERSION > /boot/version

  mv /boot/vmlinuz-lts /boot/vmlinuz-${KERNEL_VERSION}
}

# vlinux_alpine gets the virtual kernel, creates a squash with the modules.
vlinux_alpine() {
  # Also get virt since we are here...
  apk add linux-virt
  VKERNEL_VERSION=$(cat /usr/share/kernel/virt/kernel.release)
  echo $VKERNEL_VERSION > /boot/version-virt
  mv /boot/vmlinuz-virt /boot/vmlinuz-${VKERNEL_VERSION}
  ln -s /boot/vmlinuz-${VKERNEL_VERSION}  /boot/vmlinuz-virt

  mkdir -p ${WORK}/virt
  vinit $VKERNEL_VERSION
  if [ ! -f $WORK/virt/modloop-${VKERNEL_VERSION}.sqfs ]; then
    mksquashfs /lib/modules/${VKERNEL_VERSION} $WORK/virt/modloop-${VKERNEL_VERSION}.sqfs
  fi
}

# vinit updates the initramfs for the virt kernel, in case init script is changed.
vinit() {
  VKERNEL_VERSION=$(cat /boot/version-virt)

  mkinitfs  -i $SRCDIR/recovery/init -F "base btrfs squashfs virtio eudev initos" -o ${WORK}/virt/initramfs-$VKERNEL_VERSION $VKERNEL_VERSION
}

# Generate an unsigned efi image, based on alpine with a custom init script.
# alpine_initrd is run in an alpine container, rescue or chroot.
#
# The init image will be generated in /boot/initramfs.
# Modules are expected to be in /lib/modules/modules-KERNEL_VERSION
# Kernel is expected to be in /boot/vmlinux-KERNEL_VERSION
#
# For secure mode, kernel+initrd+cmdline are signed, but the rootfs needs to
# be either signed or on a LUKS partition ( where encryption+signing happens as well).
#
# In the first case, normally the SHA of the rootfs needs to be passed as an argument
# either in kernel cmdline or as a file in initrd.
#
# The '@firmware' and '@modules' subvolumes must also be created
# if using separate volumes - for now they're in @recovery rootfs.
efi() {

  # Expects that the modloop is already created, and the cache under ${WORK}/modules may
  # exist.

  KERNEL_VERSION=$(cat /boot/version)
  [ -z ${KERNEL_VERSION} ] && echo "Missing kernel config" && return

  KERNEL=/boot/vmlinuz-${KERNEL_VERSION}
  [ ! -f ${KERNEL} ] && echo "Missing kernel ${KERNEL}" && return

  [ ! -f /lib/modules/${KERNEL_VERSION}/modules.dep ] && echo "Missing modules" && return

  # Uses mkinitfs.conf added from file in the docker image.
  # Other options: virtio, squashfs, 9p, raid, cdrom, lvm, ext4, kms (video)

  # -k - keep the file
  # -t - temp dir where all is stored
  # -i - what init file to use - replace default with our script.
  #rm -rf ${WORK}/initrd
  # -k -t ${WORK}/initrd
  local img=/boot/initrd-initos.img-${KERNEL_VERSION}

  echo "features=\"ata base btrfs keymap mmc nvme scsi usb cryptsetup squashfs tpm2 clevis initos eudev\"" > /etc/mkinitfs/mkinitfs.conf
  cp /etc/passwd /usr/share/mkinitfs/passwd
  cp /etc/group /usr/share/mkinitfs/group

  mkinitfs  -i $SRCDIR/recovery/init -o ${img}  $KERNEL_VERSION

  echo "Built initramfs ${img} for ${KERNEL_VERSION}"

  echo "loglevel=6 console=ttyS0 console=tty1 net.ifnames=1 panic=5 debug_init iomem=relaxed" > /boot/cmdline

  mkdir -p /boot/efi/EFI/BOOT
  efi-mkuki \
    -c /boot/cmdline \
    -o /boot/efi/EFI/BOOT/BOOTX64.EFI \
      ${KERNEL} /boot/intel-ucode.img /boot/amd-ucode.img ${img}

  echo ${KERNEL_VERSION} > /boot/efi/version

  # InitOS-${KERNEL_VERSION}.EFI
}

# Incremental efi build - only replaces init
efi2() {
  KERNEL_VERSION=$(cat /boot/version)
  KERNEL=/boot/vmlinuz-${KERNEL_VERSION}
  local img=/boot/initrd-initos.img-${KERNEL_VERSION}
  cp $SRCDIR/recovery/init /init
 (find /init | sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > /boot/initos-xtra.cpio.gz
 (find /boot/efi/hash* | sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > /boot/initos-hashes.cpio.gz

  echo "loglevel=6 console=ttyS0 console=tty1 net.ifnames=1 panic=5 debug_init iomem=relaxed" > /boot/cmdline

  mkdir -p /boot/efi/EFI/BOOT
  efi-mkuki \
    -c /boot/cmdline \
    -o /boot/efi/EFI/BOOT/BOOTX64.EFI \
      ${KERNEL} /boot/intel-ucode.img /boot/amd-ucode.img ${img} /boot/initos-hashes.cpio.gz /boot/initos-xtra.cpio.gz

}


sqfs() {
  firmware_sqfs
  mods_sqfs $(cat /boot/version)
}

firmware_sqfs() {
  cd /x/initos/firmware
  rm -f /boot/efi/firmware.sqfs
  mksquashfs . /boot/efi/firmware.sqfs
}
mods_sqfs() {
  local ver=$1
  cd /x/initos/modules/${ver}
  rm -f /boot/efi/modules-${ver}.sqfs
  mksquashfs . /boot/efi/modules-${ver}.sqfs
}

# sign creates a signed UKI.
# The initramfs is different - the additional file will disable shell and trigger verification.
sign() {
  local KERNEL_VERSION=$(cat /boot/version)

  # Alpine expects keys on /etc/uefi-keys/{db.crt,db.key}
  if [ ! -f /etc/uefi-keys/db.crt ]; then
    sign_init
  fi
  KERNEL=/boot/vmlinuz-${KERNEL_VERSION}

  veritysetup format --root-hash-file=/boot/efi/hash.recovery /boot/efi/recovery.sqfs /boot/efi/recovery.sqfs.verity
  veritysetup format --root-hash-file=/boot/efi/hash.firmware /boot/efi/firmware.sqfs /boot/efi/firmware.sqfs.verity
  veritysetup format --root-hash-file=/boot/efi/hash.modules /boot/efi/modules-${KERNEL_VERSION}.sqfs /boot/efi/modules-${KERNEL_VERSION}.sqfs.verity

  echo "Built secure initramfs ${KERNEL_VERSION}"

  (find /boot/efi/hash* | sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > /boot/initos-hashes.cpio.gz

  echo "loglevel=6 console=ttyS0 console=tty1 net.ifnames=1 panic=5 initos.secure" > /boot/cmdline.secure

  efi-mkuki \
    -c /boot/cmdline.secure \
    -o /boot/efi/EFI/BOOT/tmp-${KERNEL_VERSION}.EFI \
      ${KERNEL} \
       /boot/intel-ucode.img /boot/amd-ucode.img /boot/initos-hashes.cpio.gz \
       /boot/initrd-initos.img-${KERNEL_VERSION}

   #    ${WORK}/initos-secure.cpio.gz

  sbsign --cert /etc/uefi-keys/db.crt --key /etc/uefi-keys/db.key \
    --output /boot/efi/EFI/BOOT/InitOS-${KERNEL_VERSION}-signed.EFI \
    /boot/efi/EFI/BOOT/tmp-${KERNEL_VERSION}.EFI

  rm /boot/efi/EFI/BOOT/tmp-${KERNEL_VERSION}.EFI

  cp /etc/uefi-keys/*.auth /boot/efi/EFI

  chmod 777 /boot/efi/EFI/*.auth

  rm /.dockerenv
  # TODO: also sign the squash and modules
}

# Generate the key pairs for signing the kernel and the disk image.
# This is done before install - as a separate step/process - the rest can be automated easily,
# but signing must be done on a secure machine and is specific to each user.
sign_init() {
  local u=${1:-h.webinf.info}

  mkdir -p /x/secure
  efi-mkkeys -s h.webinf.info
}


### Alpine specific packages for the recovery image.
# Not using "--no-cache" - and installing one by one.
# When running in docker, this will be cached to /var/cache/apk/[INDEX] - which is a mounted dir.
# /etc/apk/cache will cache the actual files

install_recovery() {
  cp -a ${SRCDIR}/recovery/sbin/* /sbin/
  cp -a -f ${SRCDIR}/recovery/etc/* /etc/
  cp -a ${SRCDIR}/recovery/home /
  cp -a ${SRCDIR}/recovery/root /
  chown -R root /root
  cp -a ${SRCDIR}/recovery/init /

  alpine_add_common
  alpine_add_base
  alpine_add_recovery

  apk add openrc-init

  (cd /etc/init.d && ln -s agetty agetty.tty1)
  (cd /etc/init.d && ln -s agetty agetty.tty2)
  (cd /etc/init.d && ln -s agetty agetty.ttyS0)
  (cd /etc/init.d && ln -s agetty agetty.hvc0)
  rc-update add agetty.tty1 boot
  rc-update add agetty.tty2 default
  rc-update add agetty.ttyS0 boot
  rc-update add agetty.hvc0 boot

  rc-update add devfs sysinit
  rc-update add dmesg sysinit

  # Those 3 can be used instead of udev
  # This is the busybox mdev
  # apk add busybox-mdev-openrc
  # busybox-mdev busybox-mdev-openrc
  #apk add mdev-conf
  #rc-update add hwdrivers sysinit
  #rc-update add mdev sysinit

  # apk add --quiet mdevd mdevd-openrc
  #rc-update add hwdrivers sysinit
  #rc-update add mdevd-init sysinit
  #rc-update add mdevd sysinit

  # modloop will load after dev-mount, read KOPT_modoop and KOPT_modloop_verify
  # checks using openssl using public key under /etc/apk/keys/*.pub
  # Modules are loaded as overlay (so more can be added)
  #rc-update del modloop sysinit
  rc-update add udev sysinit
  rc-update add udev-trigger sysinit
  rc-update add udev sysinit
  rc-update add udev-settle sysinit
  rc-update add udev-trigger sysinit
  rc-update add cgroups sysinit

  #  rc-update add connman boot
  rc-update add acpid boot
  rc-update add hwclock boot
  rc-update add syslog boot
  rc-update add ntpd boot
  rc-update add wpa_supplicant boot
  rc-update add modules boot
  rc-update add sysctl boot
  rc-update add hostname boot
  rc-update add bootmisc boot
  rc-update add syslog boot
  rc-update add hwclock boot
  rc-update add networking boot

  rc-update add dropbear default
  rc-update add udev-postmount default


  rc-update add mount-ro shutdown
  rc-update add killprocs shutdown
  rc-update add savecache shutdown

  rc-update --update
  # Temp - debug only
  # TODO: in initrd, patch /etc/shadow to remove password instead
  # would be useful with all cloud images...
  passwd -d root

}

alpine_add_common() {
    echo "https://dl-cdn.alpinelinux.org/alpine/edge/testing" >> /etc/apk/repositories
    apk -U --no-progress update

    apk list -I

    #apk add alpine-base # Installs openrc
    apk add ifupdown-ng libcap2  openrc  alpine-conf  alpine-release  busybox-openrc  busybox-suid

    apk add eudev eudev-hwids udev-init-scripts udev-init-scripts-openrc
    apk del busybox-mdev-openrc mdev-conf || true
    #setup-devd udev

    # Will add busybox-mdev as baseline
    apk add openrc
    apk add alpine-conf
    apk add   busybox-suid busybox-binsh
    apk add iw ifupdown-ng ifupdown-ng-wifi
    apk add ca-certificates-bundle
    # Using it for few things - minisign can probably be used instead.
    # 765k bin + 5M lib
    apk add openssl
    apk add ssl_client

}

# If starting with an alpine distro, add the packages we need.
alpine_add_recovery() {

  apk add rsync
  
  apk add busybox-openrc

  apk add dropbear dropbear-openrc
  # fsverity CLI
  #apk add fsverity-utils

  # To build the UKI
  apk add binutils

  apk add tpm2-tools tpm2-tss-tcti-device tpm2-tss-tcti-cmd tpm2-tss
  
  apk add lsblk

  # sgdisk gptfdisk
  apk add  parted

  apk add cryptsetup uuidgen

  apk add clevis

  apk add bridge

  # 400k
  apk add minisign

  apk add btrfs-progs

  apk add mkinitfs
  echo 'disable_trigger=yes' >> /etc/mkinitfs/mkinitfs.conf

  # 104 packages, 1.1G under lib/firmware
  # /lib/modules, /boot/vmlinuz-lts (plus config, system map)
  apk add gummiboot

  apk add efibootmgr

  apk add squashfs-tools

  # troubleshooting
  #apk add pcituils

  apk add efi-mkuki
  apk add sbsigntool

  apk add openssh-sftp-server

  apk add curl

  apk add dmidecode

  # fsck, etc
  apk add dosfstools

  apk add wpa_supplicant wpa_supplicant-openrc


  # from karios - not sure we need it
  apk add  findutils findmnt \
    htop haveged \
    iproute2 \
    irqbalance \
    lm-sensors \
    lsscsi \
    lvm2 \
    mdadm \
    smartmontools \
    sudo strace util-linux bridge 

  apk add cloud-hypervisor virtiofsd

  # similar to ujail and others - no server.
  # nsjail can listen on a port and start container on connection
  # supports macvlan
  # can act as an init (restart on exit)
  apk add nsjail

  # init with a single process. Can reap even if not running as PID1.
  apk add tini

  #apk add secureboot-hook

  # Others that may be useful but not required:

  # apk add kmod lddtree kmod-libs
  #  apk add iproute2 tcpdump procps

  # For OCI interaction
  #apk add crane
  # Can also encrypt/decrypt - 3.7M + 2M for keygen
  #apk add age

  #e2fsprogs

  # apk add lvm2

}

# Base users, groups, packages.
alpine_add_base() {
  [ -f /etc/resolv.conf ] ||  echo "nameserver 1.1.1.1" > /etc/resolv.conf


  mkdir -p /boot/efi
  mkdir -p /lib/modules
  mkdir -p /lib/firmware
  mkdir -p ${WORK}
  mkdir -p /mnt/usb

  addgroup -g 1000 build
  addgroup -g 1001 admin
  #addgroup -g 1002 tss

  adduser -G build -g "Builder" build -u 1000 -D -s /bin/sh -h /home/build
  adduser -G admin -g "Admin" admin -u 1001 -D -s /bin/sh -h /home/admin
  #adduser -G tss -g "Builder" tss -u 1002

  # Add the user to the sudoers group
  addgroup admin wheel
  addgroup build users # otherwise swayunlock fails, /etc/shaddow permissions
  addgroup build video
  addgroup build audio



  # Disable IPv6 for now - seems to be broken in some cases. Can be enabled in rootfs.
  echo "net.ipv6.conf.all.disable_ipv6 = 1" >>/etc/sysctl.conf

  chown root /root

# -H: don't create home
# -D: no pass
# -S - system user - nologin (i.e. /bin/login and passwd access will be disabled - ssh ok)
# -g - 'gecos' or name
  # Enable a system user to use login:
  #passwd -u build
  # Remove password: -d

}

ui() {
  apk add firefox-esr
  #  apk add mesa-dri-gallium
  setup-desktop sway
  apk add kitty
  apk add rofi-wayland rofi-pass rofi-top
  apk add chromium

  apk add seatd


  #apk add i3wm dbus-x11
  #apk add tint2 rofi alttab i3status

  #apk add xorg-server
  #apk add xinit

#  apk add xset
#  apk add xrandr
#  apk add xmodmap
#  apk add xinput
#  apk add xhost
#  apk add xkill
}

alpine_clear() {
  rm /var/lib/dbus/machine-id || true
  rm /etc/hostname || true
  echo "" > /etc/machine-id || true
}

alpine_add_extra() {
  apk add bash bash-completion 
}

$*
