#!/bin/sh

# Install script for Initos. It assumes we run in a recovery image or an alpine rootfs
# with all the tools needed.

# Unlike ignition (which runs in Dracut initramfs), this script runs on a full alpine OS
# with networking and the usual tools. It is not designed to wipe the disk or be declarative -
# just to configure the minimum required for the machine to boot with the signed UKI image
# and have the recovery image available.

# It does have ability to create an EFI, LUKS and btrfs filesystem on an empty disk, but
# will require explicit user action to do so on a non-empty disk. If EFI/LUKS and btrfs
# are present - it will add itself to EFI and to a btrfs subvolume.

# It can also download an OCI rootfs and save it to a subvolume, and use it on next
# boot.

# Each function should do a simple operation and be kept very simple and easy to be
# modified to fit specific needs - without having to add complex config and logic to
# hide what is actually happening.

# Will wipe a disk a create the partitions needed for initos.
# This should be called explicitly by the user - it will normally not be done automatically.
# In practice we need ~100M on the EFI, and some btrfs volume.
#
wipe_disk() {
  disk_dev=$1
  suffix=$2

  # use 100% to fill the disk. This is total, EFI and root.
  # It is possible to later use the rest of the disk for LUKS, LVM or other work partitions.

  parted --script --machine -- "${disk_dev}" mklabel gpt

  parted --script --machine -- "${disk_dev}" unit s print


  parted "$disk_dev" mkpart ESP fat32 1 2048
  parted "$disk_dev" set 1 boot on

#  parted "$disk_dev" mkpart primary ext4 2048 4096
#  parted "$disk_dev" name 2 "recovery"
#
#  parted "$disk_dev" mkpart primary ext4 4096 4596
#  parted "$disk_dev" name 3 "recovery_verity"

  # Create the Linux partition
  parted "$disk_dev" mkpart primary ext4 2048 8GiB
  parted "$disk_dev" name 2 "LUKS"

  partprobe $disk_dev

  mkfs.vfat ${disk_dev}${suffix}1 -n BOOT
}

mkcrpyt() {
  local disk_dev=$1

  export PASSPHRASE=$(openssl rand -base64 32)
  if [ -f /boot/root.pem ]; then
    echo -n "$PASSPHRASE" | openssl pkeyutl -encrypt \
         -pubin -inkey /boot/root.pem \
         -pkeyopt rsa_padding_mode:oaep \
         -pkeyopt rsa_oaep_md:sha256 \
         -out /boot/efi/DISK_RECOVERY_KEY
  fi
  echo -n $disk_dev > /boot/efi/ENCRYPTED_DISK_NAME

  echo -n "$PASSPHRASE" > /run/passphrase

  save_tpm $PASSPHRASE

  echo "Consider adding a recovery key"

  # Linux LUKS partition type is 8309
  # -v -c aes-xts-plain64 -s 512 --hash sha512 --pbkdf pbkdf2 \
  #   --iter-time 1000 --use-random
  echo -n "$PASSPHRASE" | cryptsetup luksFormat --type luks2 ${disk_dev} -

  echo -n "$PASSPHRASE" | cryptsetup luksOpen ${disk_dev} c -

  mkfs.btrfs /dev/mapper/c
  # Doesn't really matter, visible after encyption unlock.
  btrfs filesystem label /dev/mapper/c "ROOT"

  # TODO: encrypt the PASSPRASE with the root public key, save it to USB for recovery.
  # TODO: if tpm present, save it to TPM
}

add_key() {
  local disk_dev=$1
  local key_file=$2

  cat /run/passphrase | cryptsetup luksAddKey $disk_dev
}


recover_key() {
  local ENCRYPTED_PASSPHRASE_FILE=$1
  PRIVATE_KEY=$HOME/.ssh/id_ecdsa

  PASSPHRASE=$(openssl pkeyutl -decrypt \
     -inkey $PRIVATE_KEY -in $ENCRYPTED_PASSPHRASE_FILE \
     -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha256)
}

efidump() {
  mount  -t efivarfs efivarfs /sys/firmware/efi/efivars

}

gen_pass() {
   cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c14; echo
}

## Save the LUKS password to TPM
save_tpm() {
  PASSPHRASE=$1

    # Key will be disabled if ...
    # Shows the same output every time, probably fine to repeat.
    #tpm2_createpolicy --policy-pcr -l sha256:0,1,2,3 -L policy.digest
    tpm2_createpolicy --policy-pcr -l sha256:8 -L policy.digest

    tpm2_getcap handles-persistent | grep -q 0x81800001
    if [ $? -ne 0 ]; then
      # -C hierarch - e for endorsement, default is owner, also platform
      # -g sha256 - default
      # -G defaults to rsa2048:null:aes128cfb
      # -c file - where to store the 'context' (info about key)
      tpm2_createprimary -C p -c primary.ctx --format=pem --output=primary_pub.pem
      # displays info - including key handle (it seems to be temporary )
      tpm2_print -t TPMS_CONTEXT primary.ctx
      ### Handle: 0x80000000, sequence: 2, 6, 10, etc - size 1914

      # Get a persistent handle
      tpm2_evictcontrol -c primary.ctx -o primary.tr -C p
      # To remove: replace -c primary.ctx with -c 0x81800001
      tpm2 print -t ESYS_TR primary.tr
      # Should hopefully create Handle: 0x81800001
    fi

    # '-C p' worked on some where '-C e' didn't

    # not setting -L makes the key accessible in all cases

    # -i - -- stdin, max 128 bytes
    # -u and -r seem to be used to allow the object to be moved to another TPM
    # -C context (parent object) - not sure how to list
    # -r and -u - where to store the output
    echo ${PASSPHRASE} | tpm2_create -u key.pub -r key.priv -C 0x81800001 -L policy.digest -i -
    # -C 0x81000000 also works as -C - from handles-persistent
    # -c key.ctx -> also load in the same step, but ChromeOS TPM doesn't support it
    # without -i creates an RSA public key

    tpm2_evictcontrol -C p -c 0x81800002 | true
    # -c - the out file for the context for the key
    # tpm2_create generates the 'export' files.
    tpm2_load -C 0x81800001 -u key.pub -r key.priv -c key.ctx -n key.name

    # -C p - platform (only one working on my chromebook)
    # -c ctx - the key handle or ctx file
    #
    tpm2_evictcontrol -C p -c key.ctx
    # To delete -C p -c ID

     # -> returns a persistent handle (0x81800000) for 'p'

    # Show the list of handles
    tpm2_getcap handles-persistent

}

bootefi() {
  local dev=${1:-/dev/sda}

   mount -t efivarfs none /sys/firmware/efi/efivars

  efibootmgr --disk $dev --part 1 --create --label 'Initos' --load /EFI/boot/InitOS.efi --verbose

}

efibackup() {
  mkdir -p /etc/uefi-keys/vendor
  cd /etc/uefi-keys/vendor
  for i in PK KEK db dbx; do efi-readvar -v $i -o $i.esl; done

  # Installing keys:
  # db.auth,  KEK.auth and PK.auth added to bios from USB disk

  # Alternative:
  # apk update
  # apk add sbctl
  # sbctl create-keys
  # sbctl sign /boot/efi/Alpine/linux-lts.efi
  # sbctl enroll-keys -m
}


prepare_usb() {
  local disk_dev=${1:-/dev/sda}

  wipe_disk $disk_dev

  mount ${disk_dev}3 /mnt/usb/root
  mount ${disk_dev}1 /mnt/usb/efi

  cd /mnt/usb/root
  btrfs subvolume create recovery
}



$*
