#!/bin/sh

export PATH="$PATH:/usr/bin:/bin:/usr/sbin:/sbin"

# Separate script for setting up server machines with TPM2
# All servers should have TPM2 in order to start automatically.
# Without TPM2 - it is possible to start in a locked mode and 
# connect to a control plane for further instructions.
#
# In case of problems (failure to unlock, can't ssh):
# -disable secure mode (may require BIOS password)
# -boot from a USB image if disk is completely gone.
# 


# Main entry point - called by the init script
initos_init() {  
  logi "Starting INITOS TPM2 $(uname -r)"

  # Additional drivers with the real firmware and modules mounted. 
  load_drivers

  # At this point we may have a tpm and may be able to mount
  # encrypted disk.
  # If insecure - the TPM should NOT have the key
  # Without TPM2 - will ask for a password - if it can open the
  # disk - ok, otherwise panic
  mount_persistent

  start_os
}

# Called after the /x partition has been mounted.
start_os() {
  # At this point we have an encrypted disk (or we need to load recovery)
  if [ -f /x/initos/initos.env ]; then
    . /x/initos/initos.env
    mount_sysroot
  fi

  if [ ! -d /sysroot/etc ]; then
    logi "Running standalone - VMs/pods will start"
    ls /sysroot
    run_standalone
  fi

  if [ -f /sysroot/init ]; then
    logi "Preparing to switch root - custom init"
    move_mounted_to_sysroot
    exec switch_root /sysroot /init
  elif [ -f /sysroot/lib/systemd/systemd ]; then
    logi "Preparing to switch root (systemd)"
    move_mounted_to_sysroot
    exec switch_root /sysroot /usr/bin/systemd --system 
    #  systemd --log-level=err --unit=rescue.target --system --default-standard-output=tty --default-standard-error=tty
  elif [ -f /sysroot/sbin/init ]; then
    logi "Preparing to switch root"
    move_mounted_to_sysroot
    exec switch_root /sysroot /sbin/init
  fi
  lfatal "Failed to switch root"
}

mount_persistent() {
    # LUKS mounted on /x, secure mode.
    open_luks
        
    mount_btrfs_raw /dev/mapper/c /x
    if [ $? -eq 0 ]; then
        logi "BTRFS mounted"
        return 1
    fi

    return 0
}

# After mounting /lib/modules and firmware, load all drivers.
load_drivers() {
  sysctl -w kernel.printk="0 4 1 7" > /dev/null 2>&1

    # this is normally done by sysinit - we want tpm2 to be loaded
  # Needs to happen after full firmware and modules are in place
  hwdrivers > /tmp/hwdrivers.log 2>&1

  logi "hwdrivers loaded $(ls -l /dev/tpm*)"

  udevadm trigger

  udevadm settle

  logi "udevadm settle $(ls -l /dev/tpm*)"

  hwdrivers > /tmp/hwdrivers2.log 2>&1 # TPM seems to need some time to init
  
  logi "hwdrivers2 $(ls -l /dev/tpm*)"

  sysctl -w kernel.printk="2 4 1 7" > /dev/null 2>&1
}

# All remaining mounted dirs will be moved under same dir in /sysroot,
# ready to switch_root
move_mounted_to_sysroot() {
  # Will be started again in sysroot
  udevadm control --exit || true

  mkdir -p /initos/rootfs
  mkdir -p /initos/ro /initos/rw /initos/old /initos/work

  # Will be moved to /sysroot/initos
  mount -o bind / /initos/rootfs
  mount -o bind /initos/ro/rootfs /initos/ro/rootfs
  mount -o bind /initos /initos/old

  # Issues:
  # /dev/pts
  # /sysroot/run
  # /dev/shm
  # 
  # From original alpine init
  cat /proc/mounts 2>/dev/null | while read DEV DIR TYPE OPTS ; do
    if [ "$DIR" != "/" -a \
         "$DIR" != "/sysroot" -a \
         -d "$DIR" ]; then
      mkdir -p /sysroot$DIR
      mount -o move $DIR /sysroot$DIR
    fi
  done

  sync
}

# Info log - shown on console, logged.
logi() {
	last_emsg="$*"
	echo "INITOS: $last_emsg..." > /dev/kmsg
	echo "$last_emsg\n"
}

lfatal() {
  echo "FAILED: $*"
  edump

  echo "Rebooting in 20 sec"
  blkid
  
  sleep 20
  reboot -f
}

# dump info to the EFI partition (which exists if we managed to get the
#  kernel running). One goal is to support machines without display/keyboard,
# install state will be saved on the USB disk.
# Log destinations:
# - before 'boot' is mounted: in memory, console on failure to mount boot
# - after 'boot' is mounted: /z/initos/log on failure, recovery /var/log/boot
# - after 'rootfs' is mounted, on tmpfs if it works, /boot/efi if not.
#
# All 'fatal' logs go to /boot/efi if it is mounted.
edump() {
  local dst=${1:-/z/initos/log/${MAC}}

  if [ ! -e /z/initos ]; then
    echo "Boot disk not found"
    return
  fi

  # current date and time
  export LOG_DIR=${dst}/$(date +"%Y-%m-%d-%H-%M-%S")
  mkdir -p ${LOG_DIR}

  echo "$ORIG_DEVICES" > ${LOG_DIR}/devices_before_mods

  blkid > ${LOG_DIR}/blkid
  cat /proc/filesystems > ${LOG_DIR}/filesystems
  cat /proc/devices > ${LOG_DIR}/devices

  mount > ${LOG_DIR}/initrafms.mounts
  lsmod > ${LOG_DIR}/lsmod.log

  dmesg > ${LOG_DIR}/dmesg.log

  env > ${LOG_DIR}/env.log
}

# unlock the encrypted disk using the TPM. 'c' mapper will be used.

unlock_tpm() {
  local part=$1

  # Arch recommends: 1,2,5,7 ( firmware, firmware options, GPT layout, secure
  #  boot status)
  #PCRS="0,1,7"
  # 2 = pluggable executable code
  # 3 = pluggable firmware data
  # 4 = boot manager code
  # 5 = boot manager data, include GPT partitions
  # 6 = resume events
  # 7 = secure boot status, certificates -> This is what 
  #  we want, gpt layout is not relevant, firmware can be
  #  upgraded.

  # The setup script makes sure this handle is set - we may try multiple handles or
  # list nv persistent and try all.

  handle=0x81000001
  if [ -f /boot/efi/luks.handle ]; then
    handle=$(cat /boot/efi/luks.handle)
  fi

  HANDLES=$(tpm2_getcap handles-persistent)
  logi "Persistent handles $HANDLES" 
  
  PASSPHRASE=$(tpm2_unseal -c ${handle} -p pcr:sha256:7 2>/dev/null)
  if [ -z $PASSPHRASE ]; then 
    logi "Handle $handle PCR7 failed, try PCR8" 
    PASSPHRASE=$(tpm2_unseal -c ${handle} -p pcr:sha256:8 2>/dev/null)
  fi 
  # if [ -z $PASSPHRASE ]; then 
  #   logi "Handle $handle failed PCR8 try 8100..2 PCR7" 
  #   handle=0x81000002
  #   PASSPHRASE=$(tpm2_unseal -c ${handle} -p pcr:sha256:7 2>/dev/null)
  # fi 
  if [ -z $PASSPHRASE ]; then 
    logi "Handle $handle:8 failed, try 81800001" 
    handle=0x81800001
    PASSPHRASE=$(tpm2_unseal -c 0x81800001 -p pcr:sha256:7 2>/dev/null)
  fi 
  if [ -z $PASSPHRASE ]; then
    echo "Failed to unlock TPM, fallback to recovery" 
    return
  fi
  export PASSPHRASE

  if [ -z "$part" ]; then
    parts=$(blkid | grep 'TYPE="crypto_LUKS"' | cut -d: -f1 )
    for part in $parts ; do
      echo -n "$PASSPHRASE" | cryptsetup open $part c -
      if [ $? -eq 0 ]; then
        logi "Opened $part"
        return 0
      fi
    done
  else
    echo -n "$PASSPHRASE" | cryptsetup open $part c -
  fi

}


# open LUKS using TPM2.
# TODO: attempt to open all LUKS devices (multiple NVMEs)
# Mointing the /x and rootfs after, btrfs may span multiple 
# disks.
open_luks() {
  local crypted=$1
  
  echo "Found LUKS device: ${cryptd}"
  
  unlock_tpm $cryptd
  if [ $? -eq 0 ]; then
    logi "TPM unlocked ${cryptd}"
    return 0
  fi

  return 1
}

mount_btrfs_raw() {
  local root_device=${1}
  local dst=${2}

  BTRFS_OPTS="-o nobarrier"
  #  -o compress

  mkdir -p ${dst}

  mount -t btrfs "${root_device}" ${dst}
  if [ $? -ne 0 ]; then
      logi "Error: Failed to mount BTRFS partition"
      return 1
  fi
}


# Persistent disk mounted on /x
# Mount /sysroot from the BTRFS subvolume, mount 
# additional volumes.
mount_sysroot() {
  root_device=/dev/mapper/c
  x=/x

  if [ -f ${x}/swap ]; then
    swapon ${x}/swap
  fi


  if [ -z $INITOS_ROOT ]; then
    if [ -d "${x}/@" ]; then
      INITOS_ROOT="@"
    else
      INITOS_ROOT="NOTFOUND"
    fi
  fi

  mkdir -p /sysroot
  if [ -d ${x}/${INITOS_ROOT} ]; then
    mount -t btrfs "${root_device}" /sysroot -o subvol=${INITOS_ROOT} \
      -o noatime -o nodiratime
    if [ $? -ne 0 ]; then
      logi "Error: Failed to mount BTRFS partition ${INITOS_ROOT}, fallback to recovery"
    fi
  fi

  if [ -d ${x}/@home ] ; then
    mount -o bind ${x}/@home /home
  fi
  if [ -d ${x}/@cache ]; then
    mount -o bind ${x}/@cache /var/cache
  fi
  if [ -d ${x}/@log ]; then
    mount -o bind ${x}/@log /var/log
  fi

  cp -a ${x}/initios/etc /etc
}

# Scan /sys for 'modalias', sort and load the modules.
# This should load TPM if it is available
hwdrivers() {
  find /sys -name modalias -type f -print0 | xargs -0 sort -u | xargs modprobe -b -a
}

# After the LUKS has been opened and /x mounted - we can either run another (debian, arch) OS as 'root' 
# with full access to hardware or run it in VMs/jails, keeping InitOS as the main OS.
run_standalone() {
  logi "Starting INITOS standalone"
  
  if [ ! -f /x/initos/etc/ssh/ssh_host_ecdsa_key ]; then
      mkdir -p /x/initos/etc/ssh
      ssh-keygen -q -f /etc/ssh/ssh_host_ecdsa_key -N '' -t ecdsa
  fi

  # Configs baked into EFI /local dir 
  cp -a /var/initos/local/etc/* /etc
  # The encrypted disk is trusted.
  cp -a /x/initos/etc/* /etc

  # Not using init - openrc (like s5) is just a launcher for 
  # initialization scripts.
  /sbin/openrc sysinit
  /sbin/openrc boot
  
  # Normall init starts this with 'wait'
  /sbin/openrc default

  # Show the interfaces
  ifconfig -a
  cat /etc/ssh/*.pub 

    # Takes care of zombies
  exec tini -s sleep -- infinity 
}

# If running as PID=1 (from initrd): run initos_init or
# a different function (like vm_init)
if [ "$$" = "1" ]; then
  if [ -z ${1+x} ] ; then
    initos_init
  else 
    # Run one of the functions
    $*
  fi
else
  $*
fi
