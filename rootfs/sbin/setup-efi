#!/bin/sh

# Setup for the files going into the EFI partition.
# 
# Without any args, will build the USB image, with an additional signed EFI for BOOTA.
# "A" and "B" will only boot the images for the A and B partitions. 
# 
# It will start by generating Verity signatures for the .sqfs image that is generated part of the
# built, and create the EFI UKI with corresponding flags.
# 
# Create the final disk by copying to the unused existing EFI partition - the active boot can't be 
# changed, the files will be in use.

set -x
set -e

# Destination dir for the efi partition artifacts.
# May include additional files to bake into images.
# Signing the images also requires a volume holding the signing keys
# and configs.
WORK=${WORK:-/x/initos}

mkdir -p ${WORK}/efi/initos ${WORK}/efi/EFI/BOOT ${WORK}/usb/EFI/BOOT

# Generate the key pairs for signing the kernel and the disk image.
# This is done before install - as a separate step/process - the rest can be automated easily,
# but signing must be done on a secure machine and is specific to each user.
sign_init() {
  local u=${DOMAIN:-mesh.internal}

  efi-mkkeys -s ${u} -o /etc/uefi-keys

  # Generate a 'mesh root' - both SSH and https.  
  # Will be bundled on all signed images, and used to encrypt the LUKS pass.
  openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 \
     -out /etc/uefi-keys/root.key

  openssl ec -in /etc/uefi-keys/root.key -pubout -out \
     /etc/uefi-keys/root.pem
  
  ssh-keygen -y -f /etc/uefi-keys/root.key > \
     /etc/uefi-keys/authorized_keys


  echo "Generating new root keys for signing and mesh"
  cat /etc/uefi-keys/authorized_keys

  cp -a /etc/uefi-keys /config
}

# Sign will create the UKI signed, insecure and usb images.
# It will also regenerate and sign the SQFS file, and add patches
# to the UKI that will be used to configure the hosts, including 
# a 'mesh root cert', authorized keys, common configs.
#
# The patches can also be added to the SQFS file before signing.
# They go to /opt/initos/local
# 
# It is intended to run from a container with /etc/uefi-keys mounted
# to a disk on an encrypted partition or 'secrets', and /x/initos
# mounted with the destination disk, where efi image will be 
# created. It can also be used from recovery.
efi() {
  local host=${1:-default}
    
  # Mounted dir
  DEST=/data
  set -e

  # Alpine expects keys on /etc/uefi-keys/{db.crt,db.key}
  if [ ! -f /config/uefi-keys/db.crt ]; then
    ls -R /config
    sign_init
  else
    cp -a /config/uefi-keys /etc
  fi

  mkdir -p ${DEST}/initos ${DEST}/initos/KEYS /local ${DEST}/EFI/BOOT

  cp /etc/uefi-keys/*.auth ${DEST}/initos/KEYS
  cp /etc/uefi-keys/*.crt ${DEST}/initos/KEYS
  cp /etc/uefi-keys/*.cer ${DEST}/initos/KEYS
  
  # Initos image includes the recovery. It can also be built or manipulated on the
  # host.
  if [ ! -f ${DEST}/initos/initos.sqfs ]; then
    cp /boot/recovery.sqfs ${DEST}/initos/initos.sqfs
  fi

  # If hash is missing, use verity to sign it now
  # If making changes to the img (on the mounted disk), remove hash.recovery to force
  # regeneration.
  if [ ! -f ${DEST}/initos/initos.hash ]; then
    # TODO: check if older 
    veritysetup format \
      --root-hash-file=${DEST}/initos/initos.hash \
      ${DEST}/initos/initos.sqfs \
      ${DEST}/initos/initos.sqfs.verity
  fi

  # /local dir will be baked into the initrd and propagated. Include critical security files.
  # Also add fresh scripts from the image.
  cp ${DEST}/initos/initos.hash /local/initos.hash 
  cp /etc/uefi-keys/authorized_keys /local/
  cp /etc/uefi-keys/root.pem /local/
  if [ -d /config/local ]; then
    cp -a /config/local/* /local/
  fi

  # Per host local configs
  cp -a /config/hosts/${host}/local/* /local/ || true
  
  INIT_PATCH=/tmp/initrd-patch.cpio.gz
  (find /sbin/initos* /local \
   | sort  | cpio --quiet --renumber-inodes -o -H newc | gzip) > ${INIT_PATCH}

  local cmd="console=ttyS0 rdinit=/sbin/initos-initrd console=tty1 net.ifnames=0 panic=5"
 
  kernel_version=$(cat /boot/version)
  KERNEL=/boot/vmlinuz-${kernel_version}
  #UCODE="/boot/intel-ucode.img /boot/amd-ucode.img"
  UCODE=""
  # Deb kernel is compiled with ucode included
  # With the ucode - 2024-02-15

  # console log level 2 (critical)
  # default messages (no loglevel): 4 (warning)
  # min console log level
  # default console log level 7
  # cmdline: loglevel=
  #sysctl -w kernel.printk="2 4 1 7"

  # TODO: add a file an create another config.cpio - command line can be set by efibootmgr.
  # Technically if the command line can be changed an attacker can also set rdinit=/bin/sh - the bootloader must 
  # be locked down and EFI restricted just like TPM
  echo "$cmd initos=USB loglevel=6 debug_init iomem=relaxed " > /boot/cmdline.usb
  efi-mkuki \
      -c /boot/cmdline.usb \
      -o ${DEST}/EFI/BOOT/BOOTx64.EFI \
        ${KERNEL} \
        ${UCODE} /boot/initos-initrd.img ${INIT_PATCH}
 

  echo "$cmd loglevel=2 quiet " > /boot/cmdline
  efi-mkuki \
      -c /boot/cmdline \
      -o /tmp/tmp.EFI \
        ${KERNEL} \
        ${UCODE} /boot/initos-initrd.img ${INIT_PATCH}

  sbsign --cert /etc/uefi-keys/db.crt \
      --key /etc/uefi-keys/db.key \
      --output ${DEST}/initosA.EFI \
      /tmp/tmp.EFI

  rm /tmp/tmp.EFI
  chmod -R 755 ${DEST}
}

#    sigfile=${hashfile}.sig
#    cat $hashfile | xxd -r -p | openssl dgst \
#      -sha256 -sign /etc/uefi-keys/root.key \
#      -out root_hash.sig

if [ -z ${1+x} ] ; then
  efi
else
  $*
fi
