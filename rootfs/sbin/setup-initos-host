#!/bin/sh

# Install script for Initos. It assumes it was directly booted or chroot/container in the recovery image, where all
# tools are available.
# 
# wipe_disk  requires the /dev/DISK to be available - bind mount if running in a container.
# 
# 
# Init script for USB and 'debug' boot - should NOT be used with
# signed UKI images since it provides root shell access.
#
# Use for installing to signed UKI - followed by enabling secure boot.
# In case of problems - disable secure boot and use this image.
#
# Will use the rootfs from USB disk, if a USB disk is found.

# Issue: on first boot into secure mode, LUKS will not be unlocked
# since we changed the parameters. So first time requires a ssh access
# from the 'control plane' to save the key into TPM2. The control plane
# has the root key to unlock the LUKS recovery.

# Where to store the luks key during setup (some commands require a file)
SECRETS=/run/secrets/luks

# Unlike ignition (which runs in Dracut initramfs), this script runs on a full alpine OS
# with networking and the usual tools. It is not designed to wipe the disk or be declarative -
# just to configure the minimum required for the machine to boot with the signed UKI image
# and have the recovery image available.

# It does have ability to create an EFI, LUKS and btrfs filesystem on an empty disk, but
# will require explicit user action to do so on a non-empty disk. If EFI/LUKS and btrfs
# are present - it will add itself to EFI and to a btrfs subvolume.

# It can also download an OCI rootfs and save it to a subvolume, and use it on next
# boot.

# Each function should do a simple operation and be kept very simple and easy to be
# modified to fit specific needs - without having to add complex config and logic to
# hide what is actually happening.

# Check all files and meeta checksums. Reports go to /var/lib/btrfs.
# Docs recommend monthly, from cron. Will use 80% of bw.
scrub() {
  btrfs scrub start -B /x
  btrfs filesystem defrag -v -r -f -t 32M /x
  duperemove -dhr /x
  btrfs balance start -m /x
}


# Will wipe a disk a create the partitions needed for initos.
# This should be called explicitly by the user - it will normally not be done automatically.
# In practice we need ~100M on the EFI, and some btrfs volume.
#
wipe_disk() {
  disk_dev=${1:-/dev/nvme0n1}

  # if disk contains 'nvme', add 'p'
  
  # 'p' for nvme
  suffix=$2

  # use 100% to fill the disk. This is total, EFI and root.
  # It is possible to later use the rest of the disk for LUKS, LVM or other work partitions.

  # List partitions with parted
  partitions=$(parted --script --machine -- "${disk_dev}" unit s print)

  parted --script --machine -- "${disk_dev}" mklabel gpt

  # 512M would fit - but painful, better to have some
  # space.
  # a single partition is hard to manage.
  parted "$disk_dev" mkpart ESP fat32 1 1024
  parted "$disk_dev" set 1 boot on
  parted "$disk_dev" name 1 "BOOTA"

  parted "$disk_dev" mkpart ESP fat32 2 2048
  parted "$disk_dev" name 2 "BOOTB"

  # Create the LUKS partition
  parted "$disk_dev" mkpart primary ext4 2048 -1
  parted "$disk_dev" name 3 "LUKS"

  partprobe $disk_dev


  mkfs.vfat ${disk_dev}${suffix}1 -n BOOTA
  mkfs.vfat ${disk_dev}${suffix}2 -n BOOTB
}

prepare_usb() {
  local disk_dev=${1:-/dev/sda}

  wipe_disk $disk_dev

}

# This must be called after changing the partition tables.
addEFI() {
  d=${1:-/dev/nvme0n1}
  # 'p' for nvme
  suffix=$2
  efibootmgr -B -b 1001
  efibootmgr -B -b 1002
  #efibootmgr -B -b 1003

  # '-u XXXX' will override the command line - but only in insecure boot.
  # If booting insecure, this works as a USB recovery/install
  # efibootmgr -c -d ${d} -p 2 \
  #     -b 1003 \
  #     -u 'console=ttyS0 rdinit=/sbin/initos-initrd console=tty1 net.ifnames=0 panic=5 initos=USB loglevel=6 debug iomem=relaxed' \
  #     -L "InitOS InsecureB" -l "\initosA.EFI"

  efibootmgr -c -d ${d} -p 2 \
      -b 1002 \
      -L "InitOS SecureB" -l "\initosA.EFI"

  efibootmgr -c -d ${d} -p 1 \
      -L "InitOS SecureA" \
      -b 1001 \
      -l "\initosA.EFI"
 
  # -a - set active 
  # -b - modify 
  # -o - boot order
  
  # -n - set boot next
  # -N - delete boot next
  # Delete: -B -b n
  #efibootmgr --bootorder 0001,0002,0000
}

bootNext() {
  local id=$1

  rm  /sys/firmware/efi/efivars/dump-*
  efibootmgr -n $id
  sync
  reboot -f
}

upgrade_start() {
  mkdir -p /boot/b
  mount LABEL=BOOT$(cat /initos/rootfs/etc/BOOT_NEXT) /boot/b
}

upgrade_finish() {
  umount /boot/b
  local c=$(cat /initos/rootfs/etc/BOOT_CURRENT)
  if [ "$c" = "1001" ]; then 
    chroot /initos/rootfs efibootmgr -n 1002 && reboot
  else 
    chroot /initos/rootfs efibootmgr -n 1001 && reboot
  fi
}

bootNextRemote() {
  local id=$1

  rm  /sys/firmware/efi/efivars/dump-*
  if [ -e /initos/rootfs/sys/firmware ]; then 
     chroot /initos/rootfs efibootmgr -n $id
  else
     /initos/rootfs/usr/bin/arch-chroot /initos/rootfs efibootmgr -n $id
  fi
  sync
  reboot -f
}

# swapNext is useful for switching A and B as first. 
# The other approach is to upgrade B, test if it works, upgrade A while B is running - and reboot.
# That means 2 reboots and risk that B will have a late failure.
swapNext() {
  local id=$1
  if [ "$id" = "A" ]; then 
    efibootmgr -o 1001,1002
  else
    efibootmgr -o 1002,1001
  fi
}

# Create and mounts the LUKS device. key is the second param.
mkLUKS() {
  local disk_dev=$1
  local key=$2

  # Linux LUKS partition type is 8309
  # -v -c aes-xts-plain64 -s 512 --hash sha512 --pbkdf pbkdf2 \
  #   --iter-time 1000 --use-random
  echo -n "${KEY}" | cryptsetup luksFormat --type luks2 ${disk_dev} -

  echo -n "${KEY}" | cryptsetup luksOpen ${disk_dev} c -

  mkfs.btrfs /dev/mapper/c
  # Doesn't really matter, visible after encyption unlock.
  btrfs filesystem label /dev/mapper/c "ROOT"

}

xinit() {
    btrfs subvol create /x/vol
    btrfs subvol create /x/@home
    btrfs subvol create /x/@cache
    btrfs subvol create /x/@log

    # Subvolume for large images (no copy on write)
    mkdir -p /x/vol/images
    chattr +C /x/vol/images
}

# Create a LUKS encrypted filesystem, with a btrtf volume on top.
# The password is random and saved to TPM and in 'escrow' using the /boot/root.pem public key
# (that means the mesh owner can recover the passoword)
mkcrypt() {
  local disk_dev=$1

  init_pass

  save_tpm_full ${KEY}

  mkLUKS "$disk_dev" "${KEY}"
}

# Add a key to the LUKS partition. This is a recovery key, not the main key - allows owner to open the disk 
# without TPM.
luks_add_key() {
  local disk_dev=$1

  cryptsetup luksAddKey $disk_dev ${SECRETS}/key
}

luks_add_pass() {
  local disk_dev=$1
  local key_file=$2

  cat $SECRETS/key | cryptsetup luksAddKey $disk_dev
}

genpass() {
  cat /dev/urandom | \
     tr -dc a-zA-Z0-9 | \
     head -c14; echo
}

init_pass() {
  #export KEY=$(openssl rand -base64 32)
  export KEY=$(genpass)
  mkdir -p $SECRETS
  echo -n "${KEY}" > $SECRETS/key

  if [ -f /boot/root.pem ]; then
    echo -n "${KEY}" | openssl pkeutl -encrypt \
         -pubin -inkey /boot/root.pem \
         -pkeyopt rsa_padding_mode:oaep \
         -pkeyopt rsa_oaep_md:sha256 \
         -out /boot/efi/DISK_RECOVERY_KEY
  fi
}

recover_key() {
  local ENCRYPTED_PASSPHRASE_FILE=$1
  PRIVATE_KEY=$HOME/.ssh/id_ecdsa

  KEY=$(openssl pkeyutl -decrypt \
     -inkey $PRIVATE_KEY -in $ENCRYPTED_PASSPHRASE_FILE \
     -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha256)
}


HANDLE=${HANDLE:-0x81000001}

# On Chromebook, only -C p works. 
# On another laptop - default works (owner)
#   -C e also works .
#TPM_KIND="-C p"

TPM_KIND=${TPM_KIND:-}
PRIMARY=${PRIMARY:-0x81000000}
HANDLE=${HANDLE:-0x81000001}

get_pass_tpm() {
    KEY=$(tpm2_unseal -c ${HANDLE} -p pcr:sha256:7)
    echo ${KEY}
}

get_pass8() {
    KEY=$(tpm2_unseal -c 0x81000001 -p pcr:sha256:8)
    echo ${KEY}
}


list() {
  tpm2_getcap handles-persistent
}

seed() {
  # Disk is read only - but allows adding a new disk, where the writes
  # will go. This can be useful with VMs, sharing a RO base.
  btrfstune -S 1 ${dev}
}

ext4btrfs() {
  local disk=$1

  e2fsck -fvy ${disk}
  btrfs-convert ${disk}

  # btrfs subvolume delete /x/ext2_saved
}

# Run a command in a recovery chroot
recovery() {
  /initos/recovery/usr/bin/arch-chroot /initos/recovery $*
}

# On debian, find the explicitly installed packages
find_installed_deb() {
  dpkg --get-selections | grep -v deinstall | cut -f1
}


chk_firmware() {
  set +x
  # Get a list of all loaded modules - mostly AI generated.
  modules=$(lsmod | awk 'NR>1 {print $1}')

  for module in $modules; do
    modinfo_output=$(/usr/sbin/modinfo $module)

    # Extract firmware information
    #firmware_lines=$(echo "$modinfo_output" | grep -i 'firmware:')
    firmware_lines=$(echo "$modinfo_output" | grep -ioE 'firmware:[[:space:]][^ ]+' | cut -d ' ' -f2-)

    if [ -n "$firmware_lines" ]; then
      echo $module
      while read -r firmware; do
          echo "$module: $firmware"
      done < "$firmware_lines"
    fi
  done
}

get_firmware_info() {
  # Get a list of all loaded modules
  modules=$(lsmod | awk 'NR>1 {print $1}')

  for module in $modules; do
    modinfo_output=$(modinfo $module)

    # Extract firmware information
    firmware_lines=$(echo "$modinfo_output" | grep -i 'firmware:')

    if [ -n "$firmware_lines" ]; then
      echo $module "$firmware_lines"
    fi
  done
}

set_pass() { 
  mkdir -p /initos/tpm
  cd /initos/tpm
#  tpm2_getcap handles-persistent | grep -q 0x81800001
  # if [ $? -ne 0 ]; then
  # fi
  
  # Can be called multiple times, same result
  # Shows the same output every time, probably fine to repeat.
  #tpm2_createpolicy --policy-pcr -l sha256:0,1,2,3 -L policy.digest
  #tpm2_createpolicy --policy-pcr -l sha256:8 -L policy.digest

  tpm2_createpolicy --policy-pcr -l sha256:7 -L policy.digest

    # not setting -L makes the key accessible in all cases
    # -i - -- stdin, max 128 bytes
    # -u and -r seem to be used to allow the object to be moved to another TPM
    # -C context (parent object) - not sure how to list
    # -r and -u - where to store the output

  # primary.tr or 0x81000000 - the eviccontrol handle
  echo ${KEY} | tpm2_create -u key.pub -r key.priv -C ${PRIMARY} -L policy.digest -i -

  tpm2_evictcontrol -c ${HANDLE} # Delete the key. key.ctx too
  # Can use primary.ctx instead of handle ID. 
  # Should save to EFI the handles to avoid loading.
    # -c - the out file for the context for the key
    # tpm2_create generates the 'export' files.
  tpm2_load -C ${PRIMARY} -u key.pub -r key.priv -c key.ctx -n key.name
  tpm2_evictcontrol -c key.ctx ${TPM_KIND}
#   tpm2_print -t TPMS_CONTEXT key.ctx # -> Handle: 0x80000000
#   # persistent-handle: 0x81000001
}

create_primary() {
  # On Chromebook, only -C p works. On another laptop - default only (owner), -C e also works .
    # -C hierarch - e for endorsement, default is owner, also platform
    # -g sha256 - default
    # -G defaults to rsa2048:null:aes128cfb
    # -c file - where to store the 'context' (info about key)
  tpm2_createprimary  -c primary.ctx --format=pem \
     --output=primary_pub.pem ${TPM_KIND}
    # displays info - including key handle (it seems to be temporary )
  tpm2_print -t TPMS_CONTEXT primary.ctx # -> Handle: 0x80000000
    ### Handle: 0x80000000, sequence: 2, 6, 10, etc - size 1914
 
  tpm2_evictcontrol -c ${PRIMARY} # Delete the old key with this ID
    # Get a persistent handle
  tpm2_evictcontrol -c primary.ctx -o primary.tr ${TPM_KIND} # Save the key - should have the same ID
  # persistent-handle: 0x8100...0
  tpm2 print -t ESYS_TR primary.tr
}

mok() {
  mokutil --sb-state
  mokutil --list-enrolled
  mokutil --pk
  mokutil --kek
  mokutil --db
  # Looks for /var/lib/sbctl/keys/db/db.key
  # sbctl enroll-keys -a -c --yes-this-might-brick-my-machine
}

efibackup() {
  for i in PK KEK db dbx; do efi-readvar -v $i -o $i.esl; done

  # Installing keys:
  # db.auth,  KEK.auth and PK.auth added to bios from USB disk

  # Alternative:
  # apk update
  # apk add sbctl
  # sbctl create-keys
  # sbctl sign /boot/efi/Alpine/linux-lts.efi
  # sbctl enroll-keys -m
}

# host files identifies the (insecure) host config. It is used for the recovery
# image customization or for the rootfs configuration.
# In secure mode it can be signed or encrypted - but it can't hold private keys
# secure unless TPM is used - however at that point a real disk is simpler.
find_mac() {
  if [ -f /sys/class/net/wlan0/address ]; then
    export MAC=$(cat /sys/class/net/wlan0/address)
  elif [ -f /sys/class/net/eth0/address ]; then
    export MAC=$(cat /sys/class/net/eth0/address)
  else
    export MAC="00:00:00:00:00:00"
  fi

  MAC=${MAC//:/-}

}



$*
